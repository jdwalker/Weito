 #created on: Feb 22, 2012
package drools

#list any import classes here.
import pdfbox.TextData
import pdfbox.IFormatData
import pdfbox.FormatStyle
import pdfbox.TextMatch

import java.util.Set
import java.util.HashSet
import java.util.ArrayList
import java.util.List

#declare any global variables here
global ArrayList keywords
global DocumentStatistics stats

declare Wrapper
textdata : TextData @key
end

declare StyledWrapper extends Wrapper
style : FormatStyle
end

declare StyledOriginalWrapper extends StyledWrapper
end


declare Exclude
feature : Feature
end

declare Feature
name : String @key
textdata : TextData @key
wrapper : Wrapper
priority : Integer @key
end

declare Features
name: String @key
list: ArrayList @key
priority : Integer
end

declare FeaturesPriorityTracker
name : String @key
maxpriority: Integer @key
currpriority : Integer @key
end

query "Results"
$feature : DocumentFeatureResult()
end

function ArrayList<StyledWrapper> createMatchStyledWrapper(ArrayList originalWrappers, ArrayList textdatas) {
	ArrayList<StyledWrapper> results = new ArrayList<StyledWrapper>();
	for(Object genObject : textdatas) {
		TextData textdata = (TextData) genObject;
		Wrapper w = new Wrapper( textdata );
		StyledOriginalWrapper maxWrapper = null;
		double overlapRatio = 0;
		for(Object object : originalWrappers) {
			StyledOriginalWrapper ow = (StyledOriginalWrapper) object;
			if ( doWrappersOverlap(w,ow) ) {
				double newOverlapRatio = OverlapRatio(w,ow);
				if(newOverlapRatio > overlapRatio) {
				maxWrapper = ow;
				overlapRatio = newOverlapRatio;
				}
			}
		}
		if(maxWrapper != null) {
			results.add( new StyledWrapper(textdata, maxWrapper.getStyle() ) );
		}
	}
	return results;
}

function boolean doWrappersOverlap(Wrapper firstwrapper, Wrapper secondwrapper) {
	TextData firstTextData = firstwrapper.getTextdata();
	TextData secondTextData = secondwrapper.getTextdata();
	
	int firstTextStart = firstTextData.getStartpos();
	int firstTextEnd = firstTextData.getEndpos();
	
	int secondTextStart = secondTextData.getStartpos();
	int secondTextEnd = secondTextData.getEndpos();
	
	return (firstTextStart >= secondTextStart || firstTextEnd >= secondTextStart) && (secondTextStart >= firstTextStart || secondTextEnd >= firstTextStart);
}

function Double OverlapRatio(Wrapper mainWrapper, Wrapper overlappingWrapper) {
	TextData mainTextData = mainWrapper.getTextdata();
	TextData overlappingTextData = overlappingWrapper.getTextdata();
	
	Double mainTextStart = new Double( mainTextData.getStartpos() );
	Double mainTextEnd = new Double( mainTextData.getEndpos() );
	
	Double overlappingTextStart = new Double( overlappingTextData.getStartpos() );
	Double overlappingTextEnd = new Double( overlappingTextData.getEndpos() );
	
	Double mainLength = mainTextEnd - mainTextStart; // actually the length -1, but the ratios work out in the end
	Double overlappingLength = overlappingTextEnd - overlappingTextStart; // ditto
	Double overlap = (mainLength + overlappingLength - Math.abs(mainTextStart - overlappingTextStart) - Math.abs(mainTextEnd - overlappingTextEnd)) / 2; // overlap amount
	Double ratioOverlap = overlap / mainLength;
	return ratioOverlap;
}


function TextData createTextDataFromFullText(int $startpos, int $endpos, DocumentStatistics stats) {
	int startpos = clampValuestoFullText( $startpos, stats );
	int endpos = clampValuestoFullText( $endpos, stats);
	String text = stats.getFulltext().substring(startpos,endpos);
	return new TextData(startpos, endpos, text);
}

function int clampValuestoFullText(int value, DocumentStatistics stats) {
		int result = value;
		if( result > (stats.getFulltext().length() - 1) ) result = stats.getFulltext().length() - 1;
		if(result < 0) result = 0;
		return result;
}
/*
function TextData createTextData(TextDataMatcher matcher) {
	return new TextData(matcher.getStartpos(), matcher.getEndpos(), matcher.getText() );
}
*/
rule "Wrap Format Data"
ruleflow-group "genFormat"
	when
		$cd : IFormatData($text : text, $sp : startpos, $ep : endpos)
		not Wrapper(textdata.text == $text )
	then
		TextData td = new TextData( $sp, $ep, $text );
		StyledOriginalWrapper x = new StyledOriginalWrapper( td, $cd.getPrimarystyle() );
		insert( x );
end

rule "Exclusion of Features"
ruleflow-group "excludeFeatures"
	when
		$e : Exclude($f: feature )
	then
		retract($f);
		retract($e);
end

rule "setup new Features"
ruleflow-group "collectFeatures"
	when
		Feature($name : name, $td : textdata, $priority : priority)
		not Features( name.equals($name), priority == $priority )
	then
		insert( new Features($name, new ArrayList<TextData>(), $priority) );
end

rule "add new Features"
ruleflow-group "collectFeatures"
	when
		$f : Feature($name : name, $td : textdata, $priority : priority)
		$fs : Features( $list : list not contains $td, name.equals($name), priority == $priority )
	then
		$list.add($td);
		modify($fs) {
		setList($list);
		}
end

rule "define Rule Trackers"
ruleflow-group "produceResults"
	when
		Features( $name : name )
		not FeaturesPriorityTracker( name.equals($name) )
		accumulate(Features( name.equals($name), $p : priority ), $maxp : max( $p ), $minp : min($p) )
	then
		insert( new FeaturesPriorityTracker($name,$maxp.intValue(),$minp.intValue()) );
		System.out.println($name + " " + $maxp + " " + $minp);
end

rule "Increment Rule Trackers"
ruleflow-group "produceResults"
	when
		$ft : FeaturesPriorityTracker( $name : name, $priority : currpriority, currpriority <= maxpriority )
		not Features(name == $name, priority == $priority ) or Features( list.Empty )
	then
		modify ($ft) {
		setCurrpriority($priority + 1);
		}
		
end

rule "Prepare Results"
ruleflow-group "produceResults"
	when
		$fpt : FeaturesPriorityTracker( $name : name, $priority : currpriority, currpriority <= maxpriority )
		$fs : Features( name == $name, $list : list, priority == $priority, list.Empty == false )
	then
		ArrayList features = new ArrayList();
		for(Object o : $list) {
			TextData td = (TextData) o;
			features.add( td.getText() );
		}
		insert( new DocumentFeatureResult( $name, features ) );
end

rule "Title Feature"
ruleflow-group "genFeature"
no-loop
	when
		$sw : StyledWrapper(style.fontSizePt == 13 && textdata.text.length > 20)
		not Feature( wrapper == $sw )
	then
		insert( new Feature( "title",$sw.getTextdata(), $sw, 0) );
end

rule "Title Feature 1"
ruleflow-group "genFeature"

no-loop
	when
		$sw : StyledWrapper(textdata.startpos == 0)
		not Feature( name == "title", priority == 1 )
		not Feature( wrapper == $sw )
	then
		insert( new Feature( "title",$sw.getTextdata(), $sw, 1 ) );
end

/*
rule "Publication Feature"
ruleflow-group "genFeature"
no-loop
	when
		$sw: StyledWrapper($txt : textdata.text, style.fontSizePt == 7, textdata.text.length > 70 )
		//StyledWrapper(this != $sw, textdata.text.equals($txt) )
	then
	insert( new Feature( "pubname",$sw.getTextdata(), $sw, 0 ) );
end
*/


rule "Heading Feature"
ruleflow-group "genFeature"
no-loop
	when	
		$l : ArrayList() from collect( StyledOriginalWrapper() )
		$sw : StyledWrapper(  style.fontSizePt in (11.0) || (style.fontSizePt in (7.0) && style.Bold) )
/*
				or StyledWrapper() from createMatchStyledWrapper( $l, TextMatch.match("^[A-Z](\\.|:|\\)).+$", stats.fulltext)
														.orMatch("^[0-9]{1,2}(\\.|:|\\)).+$")
														.orMatch("^[IVX]+(\\.|:|\\)).+$")
														.orMatch("(?s).*A(?i)bstract.*")
														.orMatch("(?s).*R(?i)eferences.*")
														.orMatch("(?s).*(C|S)(?i)(ummary|onclusion).*")
														.orMatch("I(?i)ntroduction")
														.getResults()													
								)
*/
	then
		insert( new Feature( "heading",$sw.getTextdata(), $sw, 0) );		
end


rule "Headings not adjacent"
ruleflow-group "genFeature"
	when
		$f : Feature( name.equals("heading"), $AstartIndex : textdata.startpos )
		not Exclude($f == feature);		
		Feature( name.equals("heading"), this != $f, $BstartIndex : textdata.startpos )
		eval( Math.abs( stats.getLineIndex( $AstartIndex ) - stats.getLineIndex( $BstartIndex )  ) <= 3 ) //difference between lines one or less
	then
		insert ( new Exclude($f) );
end

rule "Abstract feature"
ruleflow-group "genMetaFeature"
no-loop
	when
		$introf : Feature(textdata.text matches ".*(?i:abstract).*", $startpos : textdata.endpos)
		$endpos : Integer() from accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos ), min ($sp) )
		not Feature(name == "abstract", priority == 0)
	then
		TextData featuretd = createTextDataFromFullText( $startpos, $endpos,stats);
		insert( featuretd);
		insert( new Feature( "abstract",featuretd, 0) );
end

rule "Abstract feature 1"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "abstract", priority == 1)
		$sw : StyledWrapper( style.italic, textdata.text.length > 150 )
	then	
		insert( new Feature( "abstract",$sw.getTextdata(), $sw, 1 ) );
end

rule "Introduction feature"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "introduction", priority == 0)
		$f : Feature( $startpos : textdata.endpos, textdata.text matches "(?s).*troduction.*")
		accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos ), $endpos : min ($sp) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos, $endpos.intValue(), stats);
		insert( featuretd);
		insert( new Feature( "introduction",featuretd, 0) );
end

rule "Introduction feature 1 - with abstract"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "introduction", priority == 1)
		$fa : Feature( name == "abstract")
		accumulate( Feature( name == "heading", $ep : textdata.startpos, textdata.text != $fa.textdata.text), $startpos : min ($ep) )
		accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos.intValue() ), $endpos : min ($sp) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos.intValue(), $endpos.intValue(), stats);
		insert( featuretd);
		insert( new Feature( "introduction",featuretd, 1) );
end

rule "Introduction feature 2 - without abstract"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "introduction", priority == 2)
		not Feature( name == "abstract")
		accumulate( Feature( name == "heading", $ep : textdata.startpos), $startpos : min ($ep) )
		accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos.intValue() ), $endpos : min ($sp) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos.intValue(), $endpos.intValue(), stats);
		insert( featuretd);
		insert( new Feature( "introduction",featuretd, 2) );
end

rule "Conclusion feature"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "conclusion")
		$introf : Feature(textdata.text matches ".*(C|S)(?i)(ummary|onclusion).*", $startpos : textdata.endpos)
		accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos ), $endpos : min ($sp) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos, $endpos.intValue(), stats);
		insert( featuretd);
		insert( new Feature( "conclusion",featuretd, 0) );
end

rule "Conclusion feature 1 - with references"
ruleflow-group "genMetaFeature"
no-loop
	no-loop
	when
		not Feature(name == "conclusion", priority == 1)
		$fr : Feature( name == "references")
		accumulate( Feature( name == "heading", $ep : textdata.startpos, textdata.text != $fr.textdata.text), $startpos : max ($ep) )
		accumulate( Feature( name == "heading", $sp : textdata.startpos, $sp > $startpos.intValue() ), $endpos : max ($sp) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos.intValue(), $endpos.intValue(), stats);
		insert( featuretd);
		insert( new Feature( "conclusion",featuretd, 1) );
end

rule "Conclusion feature 2 - without references"
ruleflow-group "genMetaFeature"
no-loop
	no-loop
	when
		not Feature(name == "conclusion", priority == 2)
		not Feature( name == "references")
		accumulate( Feature( name == "heading", $ep : textdata.startpos), $startpos : max ($ep) )
	then
		TextData featuretd = createTextDataFromFullText( $startpos.intValue(), stats.getFulltext().length() - 1, stats);
		insert( featuretd);
		insert( new Feature( "conclusion",featuretd, 2) );
end

rule "References feature"
ruleflow-group "genMetaFeature"
no-loop
	when
		not Feature(name == "references")
		$introf : Feature(textdata.text matches "(?s).*(?i)references.*", $startpos : textdata.endpos)
	then		
		int endpos = stats.getFulltext().length() - 1;
		TextData featuretd = createTextDataFromFullText( $startpos, endpos, stats);
		insert( featuretd);
		insert( new Feature( "references",featuretd, 1) );
end
